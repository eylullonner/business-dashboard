import streamlit as st
import pandas as pd
import json
from datetime import datetime
import sys
import os

# Path ayarƒ±
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
from utils.pocketbase_client import (
    get_all_data, bulk_upload_records, test_pocketbase_connection,
    get_record_count, delete_record, test_single_record_upload,
    get_collection_schema
)

# Sayfa konfig√ºrasyonu
st.set_page_config(
    page_title="Data Management",
    page_icon="üìÅ",
    layout="wide"
)

st.title("üìÅ Data Management")
st.markdown("Upload, manage and view your order matching data")

# PocketBase connection test
col1, col2, col3 = st.columns([2, 1, 1])
with col3:
    if st.button("üîó Test Connection"):
        with st.spinner("Testing connection..."):
            is_connected, message = test_pocketbase_connection()
            if is_connected:
                st.success(f"‚úÖ {message}")
            else:
                st.error(f"‚ùå {message}")

# Ana sekmeler
tab1, tab2, tab3, tab4 = st.tabs(["üì§ Upload Data", "üìä View Data", "üóëÔ∏è Delete Data", "üîß Debug Tools"])

# Tab 1: Upload Data
with tab1:
    st.subheader("üì§ Upload Matched Orders")

    uploaded_file = st.file_uploader(
        "Select JSON file with matched orders",
        type=['json'],
        help="Upload the JSON file generated by Order Matcher"
    )

    if uploaded_file:
        try:
            # JSON dosyasƒ±nƒ± oku
            json_data = json.loads(uploaded_file.read())

            if not isinstance(json_data, list):
                st.error("‚ùå JSON file should contain an array of orders")
                st.stop()

            st.success(f"‚úÖ JSON file loaded with {len(json_data)} orders")

            # √ñnizleme
            with st.expander("üîç Data Preview"):
                if len(json_data) > 0:
                    st.json(json_data[0])  # ƒ∞lk kaydƒ± g√∂ster

            # Upload butonu
            col1, col2, col3 = st.columns([1, 2, 1])
            with col2:
                if st.button("üöÄ Transfer to PocketBase", type="primary", use_container_width=True):

                    # Progress tracking
                    progress_bar = st.progress(0)
                    status_text = st.empty()


                    def update_progress(current, total, order_id):
                        progress = current / total
                        progress_bar.progress(progress)
                        status_text.text(f"Processing: {current}/{total} - {order_id}")


                    # Upload
                    with st.spinner("Uploading to PocketBase..."):
                        results = bulk_upload_records(json_data, progress_callback=update_progress)

                    # Progress tamamlandƒ±
                    progress_bar.progress(1.0)
                    status_text.text("‚úÖ Synchronization completed!")

                    # Sonu√ßlarƒ± g√∂ster
                    col1, col2, col3, col4 = st.columns(4)

                    with col1:
                        st.metric("Total Records", len(json_data))
                    with col2:
                        st.metric("Added", results["added"], delta=results["added"])
                    with col3:
                        st.metric("Updated", results["updated"], delta=results["updated"])
                    with col4:
                        st.metric("Errors", results["errors"], delta=results["errors"])

                    # Hata detaylarƒ±
                    if results["errors"] > 0:
                        with st.expander("‚ùå Error Details"):
                            for error in results["error_details"]:
                                st.error(error)

                    if results["added"] > 0 or results["updated"] > 0:
                        st.success("üéâ Data synchronization completed successfully!")

                        # Cache'i temizle
                        st.cache_data.clear()

        except json.JSONDecodeError:
            st.error("‚ùå Invalid JSON file format")
        except Exception as e:
            st.error(f"‚ùå Error reading file: {str(e)}")

# Tab 2: View Data
with tab2:
    st.subheader("üìä View Data")

    col1, col2 = st.columns([3, 1])

    with col1:
        st.info(f"üìä Total records in database: {get_record_count()}")

    with col2:
        if st.button("üîÑ Refresh Data"):
            st.cache_data.clear()
            st.rerun()

    # Veri y√ºkleme
    try:
        data = get_all_data()

        if data:
            df = pd.DataFrame(data)

            # Kolon se√ßimi
            if len(df.columns) > 10:
                selected_columns = st.multiselect(
                    "Select columns to display:",
                    options=df.columns.tolist(),
                    default=df.columns.tolist()[:10]
                )
            else:
                selected_columns = df.columns.tolist()

            if selected_columns:
                # Sayfalama
                page_size = st.selectbox("Records per page:", [10, 25, 50, 100], index=1)

                total_pages = (len(df) - 1) // page_size + 1

                if total_pages > 1:
                    page = st.number_input(
                        f"Page (1-{total_pages}):",
                        min_value=1,
                        max_value=total_pages,
                        value=1
                    )

                    start_idx = (page - 1) * page_size
                    end_idx = start_idx + page_size

                    df_display = df[selected_columns].iloc[start_idx:end_idx]

                    st.info(f"Showing records {start_idx + 1}-{min(end_idx, len(df))} of {len(df)}")
                else:
                    df_display = df[selected_columns]

                # Tabloyu g√∂ster
                st.dataframe(df_display, use_container_width=True)

                # ƒ∞ndirme se√ßenekleri
                col1, col2 = st.columns(2)

                with col1:
                    json_data = df.to_json(orient='records', indent=2)
                    st.download_button(
                        label="üìÑ Download as JSON",
                        data=json_data,
                        file_name=f"matched_orders_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json",
                        mime="application/json"
                    )

                with col2:
                    csv_data = df.to_csv(index=False)
                    st.download_button(
                        label="üìä Download as CSV",
                        data=csv_data,
                        file_name=f"matched_orders_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv",
                        mime="text/csv"
                    )

        else:
            st.info("üìä No data available. Upload some data first.")

    except Exception as e:
        st.error(f"‚ùå Error loading data: {str(e)}")

# Tab 3: Delete Data
with tab3:
    st.subheader("üóëÔ∏è Delete Data")

    st.warning("‚ö†Ô∏è This action cannot be undone!")

    # Veri y√ºkleme
    try:
        data = get_all_data()

        if data:
            df = pd.DataFrame(data)

            # Silme se√ßenekleri
            delete_option = st.radio(
                "Select delete option:",
                ["Delete specific records", "Delete all records"]
            )

            if delete_option == "Delete specific records":
                # Master no ile silme
                master_nos = df['master_no'].tolist() if 'master_no' in df.columns else []

                if master_nos:
                    selected_master_nos = st.multiselect(
                        "Select records to delete (by master_no):",
                        options=master_nos
                    )

                    if selected_master_nos:
                        if st.button("üóëÔ∏è Delete Selected Records", type="primary"):
                            with st.spinner("Deleting records..."):
                                deleted_count = 0
                                error_count = 0

                                for master_no in selected_master_nos:
                                    # Master no ile ID bul
                                    record = df[df['master_no'] == master_no].iloc[0]
                                    record_id = record['id']

                                    success, message = delete_record(record_id)

                                    if success:
                                        deleted_count += 1
                                    else:
                                        error_count += 1
                                        st.error(f"Error deleting master_no {master_no}: {message}")

                                if deleted_count > 0:
                                    st.success(f"‚úÖ {deleted_count} records deleted successfully!")
                                    st.cache_data.clear()
                                    st.rerun()

                                if error_count > 0:
                                    st.error(f"‚ùå {error_count} records could not be deleted")

                else:
                    st.info("No records available for deletion")

            else:  # Delete all records
                st.error("‚ö†Ô∏è You are about to delete ALL records!")

                confirm_text = st.text_input("Type 'DELETE ALL' to confirm:")

                if confirm_text == "DELETE ALL":
                    if st.button("üóëÔ∏è DELETE ALL RECORDS", type="primary"):
                        with st.spinner("Deleting all records..."):
                            deleted_count = 0
                            error_count = 0

                            for _, record in df.iterrows():
                                success, message = delete_record(record['id'])

                                if success:
                                    deleted_count += 1
                                else:
                                    error_count += 1

                            if deleted_count > 0:
                                st.success(f"‚úÖ {deleted_count} records deleted successfully!")
                                st.cache_data.clear()
                                st.rerun()

                            if error_count > 0:
                                st.error(f"‚ùå {error_count} records could not be deleted")

        else:
            st.info("üìä No data available to delete")

    except Exception as e:
        st.error(f"‚ùå Error loading data for deletion: {str(e)}")

# Tab 4: Debug Tools
with tab4:
    st.subheader("üîß Debug Tools")

    col1, col2 = st.columns(2)

    with col1:
        if st.button("üîç Test Collection Schema", use_container_width=True):
            with st.spinner("Getting collection schema..."):
                try:
                    schema = get_collection_schema()

                    if schema:
                        st.success("‚úÖ Schema retrieved!")
                        st.json(schema)
                    else:
                        st.error("‚ùå Could not get schema")
                except Exception as e:
                    st.error(f"‚ùå Schema error: {e}")

    with col2:
        if st.button("üß™ Test Single Record Upload", use_container_width=True):
            with st.spinner("Testing single record upload..."):
                try:
                    success = test_single_record_upload()

                    if success:
                        st.success("‚úÖ Test record uploaded successfully!")
                    else:
                        st.error("‚ùå Test record upload failed - check console for details")
                except Exception as e:
                    st.error(f"‚ùå Test upload error: {e}")

    # Show recent logs
    if st.button("üìã Show Debug Output", use_container_width=True):
        st.info("üí° Check your terminal/console where Streamlit is running for detailed debug output!")

        # Sample debug output display
        with st.expander("Expected Debug Output Example"):
            st.code("""
DEBUG - Uploading record with keys: ['master_no', 'ebay_order_number', ...]
DEBUG - Response status: 400
DEBUG - Field errors: {'amazon_product_title': {'code': 'validation_invalid_value', 'message': 'Field is too long'}}
            """)

    # Show current PocketBase connection status
    st.markdown("#### üîó Connection Status")
    try:
        is_connected, message = test_pocketbase_connection()

        if is_connected:
            st.success(f"‚úÖ {message}")
        else:
            st.error(f"‚ùå {message}")
    except Exception as e:
        st.error(f"‚ùå Connection test failed: {e}")

# Footer
st.markdown("---")
st.caption("üìÅ Data Management | Manage your order matching data")